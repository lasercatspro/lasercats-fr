export const meta = {
  author: 'Louis Quenault',
	type: 'post',
  date: '2022-09-12',
  title: 'Comment passer une mÃ©thode en argument avec Ruby ? (sans la jouer)',
  description:
    "En Ruby, appeler le nom dâ€™une mÃ©thode lâ€™exÃ©cute, mais lâ€™appeler sous une forme de symbole ou dâ€™une string permet dâ€™y faire rÃ©fÃ©rence sans lâ€™exÃ©cuter.",
	imagePreview: "/assets/images/articles/exemple-1.png"
}

export default (props) => <article meta={meta} {...props} />

En voulant crÃ©er une mÃ©thode Rails pour prendre en compte la pagination lors de requÃªtes Ã  une API, jâ€™ai eu besoin de passer une mÃ©thode en argument pour me permettre de vÃ©rifier la prÃ©sence dâ€™autres pages dans la rÃ©ponse de ma requÃªte. 

Mon objectif Ã©tait de pouvoir garder mes mÃ©thodes de requÃªtes dÃ©jÃ  existantes, tout en appelant une logique de pagination si besoin.

En mâ€™inspirant [dâ€™un article de Ross Kaffenberger](https://rossta.net/blog/paginated-resources-in-ruby.html), jâ€™ai donc codÃ© une mÃ©thode qui me permet de checker le nombre de page dâ€™une requÃªte et si besoin aller requÃªter les autres pages. 

Ayant dÃ©jÃ  mes mÃ©thodes de requÃªte, je souhaitais, non pas Ã©crire le endpoint de ma requÃªte en argument comme Ross, mais **directement passer ma mÃ©thode en argument**. 

```ruby
def paginate_get(request, dig_options)
	response = method(request).call
	objects = response[dig_options]
	number_of_pages = response.dig('meta', 'X-Total-Pages').to_i
	return objects if number_of_pages == 1

	actual_page = 2
	while actual_page <= number_of_pages
		objects += method(request).call(query: {page: actual_page}[dig_options]
		actual_page += 1
	end
	Rails.logger.debug { "I dit it #{actual_page - 1} times"}
	objects
end
```

{/* <img src={"/assets/images/articles/exemple-1.png"} alt="passer une methode en argument - exemple 1" /> */}


Beaucoup de lignes, mais en gros :

Je rÃ©cupÃ¨re ma requÃªte et des options de recherche, avec Ã§a je peux lancer une premiÃ¨re requÃªte. Jâ€™enregistre les ressources prÃ©sentes dans la premiÃ¨re rÃ©ponse de ma requÃªte ; je check sâ€™il y a plus dâ€™une page ; si non je renvoie les ressources dÃ©jÃ  prÃ©sentes ; si oui je check les autres pages pour en ajouter de nouvelles.

AprÃ¨s avoir codÃ© cette solution, jâ€™ai *naÃ¯vement* appelÃ© ma mÃ©thode de pagination en passant en argument le nom de la requÃªte que je souhaitais paginer. 

Comme Ã§a :

<img src={"/assets/images/articles/exemple-2.png"} alt="passer une methode en argument - exemple 2" />


Mal mâ€™en a pris ! **Renseigner le nom dâ€™une mÃ©thode, mÃªme en argument dâ€™une mÃ©thode, joue la mÃ©thode en question** et renvoie une erreur.

Ce que je souhaite, câ€™est que ma solution gÃ¨re lâ€™exÃ©cution de la requÃªte, la mise en cache de la rÃ©ponse, sa lecture et la solution Ã  exÃ©cuter en fonction de sâ€™il y a plusieurs pages ou non.

La solution est fournie directement par les propriÃ©tÃ©s de Ruby qui nous permettent **dâ€™utiliser des mÃ©thodes de mÃ©ta-programmation coupler Ã  une syntaxe** pour faire rÃ©fÃ©rence Ã  dâ€™autres mÃ©thodes. Ici grÃ¢ce Ã  la mÃ©thode `method()` (ğŸ˜…) et en passant le nom de ma mÃ©thode de requÃªte en string ou en symbole me permet dâ€™y faire rÃ©fÃ©rence. 

Il nous reste plus quâ€™Ã  nommer la mÃ©thode Ã  passer en argument sous forme de symbole lorsque lâ€™on appelle la mÃ©thode de pagination et le tour est jouÃ©. 

<img src={"/assets/images/articles/exemple-3.png"} alt="passer une methode en argument - exemple 3" />

Notons deux choses dans notre cas :

En Ruby, **je peux rÃ©fÃ©rer Ã  une mÃ©thode en la nommant via une string ou un symbole**, puis utiliser des mÃ©thodes de mÃ©ta-programmation pour lâ€™exÃ©cuter.

GrÃ¢ce Ã  cela nous pouvons **allÃ©ger la communication avec des API**, par exemple dans le cas oÃ¹ on a besoin de paginer les rÃ©ponses Ã  une requÃªte pour obtenir toutes les ressources souhaiter. Cette solution mâ€™a permis de **rÃ©duire au minimum le nombre de requÃªte** que jâ€™ai Ã  effectuer pour rÃ©cupÃ©rer tous mes articles, je nâ€™effectue quâ€™une seule requÃªte de base. RequÃªte qui me permet Ã  la fois de stocker des ressources, vÃ©rifier le nombre de page et exÃ©cuter de nouvelles requÃªtes si besoin. 

Retenons que, en Ruby, **appeler le nom dâ€™une mÃ©thode lâ€™exÃ©cute**, mais **lâ€™appeler sous une forme de symbole ou dâ€™une string permet dâ€™y faire rÃ©fÃ©rence sans lâ€™exÃ©cuter.**